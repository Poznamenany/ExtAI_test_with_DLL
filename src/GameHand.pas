unit GameHand;
interface
uses
  Windows, System.SysUtils,
  HandAI_Ext, ExtAIUtils, ExtAIDataTypes;

type
  // Game class for Hand. It hides the ExtAI inside of it
  TGameHand = class
  private
    fHandIndex: Integer;
    fExtAIHand: THandAI_Ext;
    fOnLog: TLogEvent;

    // Log
    procedure Log(aLog: wStr);
  public
    property HandIndex: Integer read fHandIndex;

    constructor Create(aHandIndex: Integer; aLog: TLogEvent; aExtAIHand: THandAI_Ext); reintroduce;
    destructor Destroy; override;

    procedure UpdateState(aTick: Integer);
  end;

implementation


{ TGameHand }
constructor TGameHand.Create(aHandIndex: Integer; aLog: TLogEvent; aExtAIHand: THandAI_Ext);
begin
  inherited Create();
  fHandIndex := aHandIndex;
  fOnLog := aLog;

  fExtAIHand := aExtAIHand;

  Log('  TGameHand-Create: ID = '+IntToStr(fHandIndex));
end;


destructor TGameHand.Destroy();
begin
  FreeAndNil(fExtAIHand);
  Log('  TGameHand-Destroy: ID = '+IntToStr(fHandIndex));
  inherited;
end;


procedure TGameHand.Log(aLog: wStr);
begin
  if Assigned(fOnLog) then
    fOnLog(aLog);
end;


procedure TGameHand.UpdateState(aTick: Integer);
const
  FIRST_TICK = 1;
begin
  if aTick = FIRST_TICK then
    fExtAIHand.OnMissionStart;

  fExtAIHand.OnTick(aTick);

  {
  //@Martin: todo
  if aTick = 5 then
    fExtAIHand.OnTick(aTick); // Call function in ExtAI (event)
    // if ExtAI call XYZ action then XYZ procedures in THandAIExt will be called
    // if ExtAI call XYZ state then XYZ procedure in TExtAIQueueStates will be called

  if aTick = 6 then
    fExtAIHand.OnTick(aTick);
    // if ExtAI call XYZ action then XYZ procedures in THandAIExt will be called
    // if ExtAI call XYZ state then XYZ procedure in TExtAIQueueStates will be called

  if aTick = 7 then
    fExtAIHand.OnTick(aTick);
    // if ExtAI call XYZ action then XYZ procedures in THandAIExt will be called
    // if ExtAI call XYZ state then XYZ procedure in TExtAIQueueStates will be called

  if aTick = 8 then
    fExtAIHand.OnTick(aTick);
    // if ExtAI call XYZ action then XYZ procedures in THandAIExt will be called
    // if ExtAI call XYZ state then XYZ procedure in TExtAIQueueStates will be called

  if aTick = 9 then
    fExtAIHand.OnTick(aTick);
    // if ExtAI call XYZ action then XYZ procedures in THandAIExt will be called
    // if ExtAI call XYZ state then XYZ procedure in TExtAIQueueStates will be called

  if aTick = 10 then
    fExtAIHand.OnTick(aTick);
    // if ExtAI call XYZ action then XYZ procedures in THandAIExt will be called
    // if ExtAI call XYZ state then XYZ procedure in TExtAIQueueStates will be called

  //@Krom: I need everything in 1 tick to make stress test

  For better understanding:

    Events
      from GameThread - the game can call fExtAIHand[X].NameOfEvent(...) at any time
      to ExtAI
        SingleThread - event is called directly, the ExtAI can react immediately
        MultiThread - events are stored into TExtAIQueueEvents, the ExtAI thread
                      checks the queue every loop of TExtAIThread.Execute function
                      (and sleeps if there is nothing)

    Actions
      from ExtAI - the ExtAI can call Actions.NameOfAction(...) at any time
      to GameThread - entry functions are in THandAIExt
        SingleThread - actions are called immediately and directly by the ExtAI
        MultiThread - actions are called on new tick event registration in
                      TExtAIQueueEvents.OnTick => if GameThread creates OnTick
                      event, then all actions are called from the queue

    States
      from GameThread - new states are generated by command fExtAI.QueueStates.ExtractStates();
                        in the TGameThread.Execute (1 call = 1 class)
                        after creation of new class there is check of old classes
                        if they are not reserved by ExtAI, then they are freed
      to ExtAI - States of 1 tick are stored in separate clas in "processed" format
                 so ExtAI just send request and receive data (no delay)
        SingleThread - there is just 1 class ExtAIStates
        MultiThread - the latest class of ExtAIStates is locked so ExtAI can read
                      data (there can be MAX_HANDS + 1 classes of ExtAIStates
                      in the worst case)

  }
end;


end.
